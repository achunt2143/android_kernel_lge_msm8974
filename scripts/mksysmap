#!/bin/sh -x
# Based on the vmlinux file create the System.map file
# System.map is used by module-init tools and some debugging
# tools to retrieve the actual addresses of symbols in the kernel.
#
# Usage
<<<<<<< HEAD
# mksysmap vmlinux System.map
=======
# mksysmap vmlinux System.map [exclude]
>>>>>>> 26f1d324c6e (tools: use basename to identify file in gen-mach-types)


#####
# Generate System.map (actual filename passed as second argument)
<<<<<<< HEAD

# $NM produces the following output:
# f0081e80 T alloc_vfsmnt

#   The second row specify the type of the symbol:
#   A = Absolute
#   B = Uninitialised data (.bss)
#   C = Comon symbol
#   D = Initialised data
#   G = Initialised data for small objects
#   I = Indirect reference to another symbol
#   N = Debugging symbol
#   R = Read only
#   S = Uninitialised data for small objects
#   T = Text code symbol
#   U = Undefined symbol
#   V = Weak symbol
#   W = Weak symbol
#   Corresponding small letters are local symbols

# For System.map filter away:
#   a - local absolute symbols
#   U - undefined global symbols
#   N - debugging symbols
#   w - local weak symbols

# readprofile starts reading symbols when _stext is found, and
# continue until it finds a symbol which is not either of 'T', 't',
# 'W' or 'w'. __crc_ are 'A' and placed in the middle
# so we just ignore them to let readprofile continue to work.
# (At least sparc64 has __crc_ in the middle).

$NM -n $1 | grep -v '\( [aNUw] \)\|\(__crc_\)\|\( \$[adt]\)' > $2

=======
# The following refers to the symbol type as per nm(1).

# readprofile starts reading symbols when _stext is found, and
# continue until it finds a symbol which is not either of 'T', 't',
# 'W' or 'w'.
#

${NM} -n ${1} | sed >${2} -e "
# ---------------------------------------------------------------------------
# Ignored symbol types
#

# a: local absolute symbols
# N: debugging symbols
# U: undefined global symbols
# w: local weak symbols
/ [aNUw] /d

# ---------------------------------------------------------------------------
# Ignored prefixes
#  (do not forget a space before each pattern)

# local symbols for ARM, MIPS, etc.
/ \\$/d

# local labels, .LBB, .Ltmpxxx, .L__unnamed_xx, .LASANPC, etc.
/ \.L/d

# arm64 EFI stub namespace
/ __efistub_/d

# arm64 local symbols in PIE namespace
/ __pi_\\$/d
/ __pi_\.L/d

# arm64 local symbols in non-VHE KVM namespace
/ __kvm_nvhe_\\$/d
/ __kvm_nvhe_\.L/d

# lld arm/aarch64/mips thunks
/ __[[:alnum:]]*Thunk_/d

# CFI type identifiers
/ __kcfi_typeid_/d
/ __kvm_nvhe___kcfi_typeid_/d
/ __pi___kcfi_typeid_/d

# CRC from modversions
/ __crc_/d

# EXPORT_SYMBOL (symbol name)
/ __kstrtab_/d

# EXPORT_SYMBOL (namespace)
/ __kstrtabns_/d

# ---------------------------------------------------------------------------
# Ignored suffixes
#  (do not forget '$' after each pattern)

# arm
/_from_arm$/d
/_from_thumb$/d
/_veneer$/d

# ---------------------------------------------------------------------------
# Ignored symbols (exact match)
#  (do not forget a space before and '$' after each pattern)

# for LoongArch?
/ L0$/d

# ppc
/ _SDA_BASE_$/d
/ _SDA2_BASE_$/d

# ---------------------------------------------------------------------------
# Ignored patterns
#  (symbols that contain the pattern are ignored)

# ppc stub
/\.long_branch\./d
/\.plt_branch\./d

# ---------------------------------------------------------------------------
# Ignored kallsyms symbols
#
# If the 3rd parameter exists, symbols from it will be omitted from the output.
# This makes kallsyms have the identical symbol lists in the step 1 and 2.
# Without this, the step2 would get new symbols generated by scripts/kallsyms.c
# when CONFIG_KALLSYMS_ALL is enabled. That might require one more pass.
$(if [ $# -ge 3 ]; then ${NM} ${3} | sed -n '/ U /!s:.* \([^ ]*\)$:/ \1$/d:p'; fi)
"
>>>>>>> 26f1d324c6e (tools: use basename to identify file in gen-mach-types)
