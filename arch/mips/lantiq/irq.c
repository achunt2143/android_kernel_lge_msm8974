<<<<<<< HEAD
/*
 *  This program is free software; you can redistribute it and/or modify it
 *  under the terms of the GNU General Public License version 2 as published
 *  by the Free Software Foundation.
 *
 * Copyright (C) 2010 John Crispin <blogic@openwrt.org>
=======
// SPDX-License-Identifier: GPL-2.0-only
/*
 *
 * Copyright (C) 2010 John Crispin <john@phrozen.org>
>>>>>>> 26f1d324c6e (tools: use basename to identify file in gen-mach-types)
 * Copyright (C) 2010 Thomas Langer <thomas.langer@lantiq.com>
 */

#include <linux/interrupt.h>
#include <linux/ioport.h>
<<<<<<< HEAD
=======
#include <linux/sched.h>
#include <linux/irqchip.h>
#include <linux/irqdomain.h>
#include <linux/of.h>
#include <linux/of_address.h>
#include <linux/of_irq.h>
>>>>>>> 26f1d324c6e (tools: use basename to identify file in gen-mach-types)

#include <asm/bootinfo.h>
#include <asm/irq_cpu.h>

#include <lantiq_soc.h>
#include <irq.h>

<<<<<<< HEAD
/* register definitions */
#define LTQ_ICU_IM0_ISR		0x0000
#define LTQ_ICU_IM0_IER		0x0008
#define LTQ_ICU_IM0_IOSR	0x0010
#define LTQ_ICU_IM0_IRSR	0x0018
#define LTQ_ICU_IM0_IMR		0x0020
#define LTQ_ICU_IM1_ISR		0x0028
#define LTQ_ICU_OFFSET		(LTQ_ICU_IM1_ISR - LTQ_ICU_IM0_ISR)

#define LTQ_EIU_EXIN_C		0x0000
#define LTQ_EIU_EXIN_INIC	0x0004
#define LTQ_EIU_EXIN_INEN	0x000C

/* irq numbers used by the external interrupt unit (EIU) */
#define LTQ_EIU_IR0		(INT_NUM_IM4_IRL0 + 30)
#define LTQ_EIU_IR1		(INT_NUM_IM3_IRL0 + 31)
#define LTQ_EIU_IR2		(INT_NUM_IM1_IRL0 + 26)
#define LTQ_EIU_IR3		INT_NUM_IM1_IRL0
#define LTQ_EIU_IR4		(INT_NUM_IM1_IRL0 + 1)
#define LTQ_EIU_IR5		(INT_NUM_IM1_IRL0 + 2)
#define LTQ_EIU_IR6		(INT_NUM_IM2_IRL0 + 30)

#define MAX_EIU			6

/* irqs generated by device attached to the EBU need to be acked in
=======
/* register definitions - internal irqs */
#define LTQ_ICU_ISR		0x0000
#define LTQ_ICU_IER		0x0008
#define LTQ_ICU_IOSR		0x0010
#define LTQ_ICU_IRSR		0x0018
#define LTQ_ICU_IMR		0x0020

#define LTQ_ICU_IM_SIZE		0x28

/* register definitions - external irqs */
#define LTQ_EIU_EXIN_C		0x0000
#define LTQ_EIU_EXIN_INIC	0x0004
#define LTQ_EIU_EXIN_INC	0x0008
#define LTQ_EIU_EXIN_INEN	0x000C

/* number of external interrupts */
#define MAX_EIU			6

/* the performance counter */
#define LTQ_PERF_IRQ		(INT_NUM_IM4_IRL0 + 31)

/*
 * irqs generated by devices attached to the EBU need to be acked in
>>>>>>> 26f1d324c6e (tools: use basename to identify file in gen-mach-types)
 * a special manner
 */
#define LTQ_ICU_EBU_IRQ		22

<<<<<<< HEAD
#define ltq_icu_w32(x, y)	ltq_w32((x), ltq_icu_membase + (y))
#define ltq_icu_r32(x)		ltq_r32(ltq_icu_membase + (x))
=======
#define ltq_icu_w32(vpe, m, x, y)	\
	ltq_w32((x), ltq_icu_membase[vpe] + m*LTQ_ICU_IM_SIZE + (y))

#define ltq_icu_r32(vpe, m, x)		\
	ltq_r32(ltq_icu_membase[vpe] + m*LTQ_ICU_IM_SIZE + (x))
>>>>>>> 26f1d324c6e (tools: use basename to identify file in gen-mach-types)

#define ltq_eiu_w32(x, y)	ltq_w32((x), ltq_eiu_membase + (y))
#define ltq_eiu_r32(x)		ltq_r32(ltq_eiu_membase + (x))

<<<<<<< HEAD
static unsigned short ltq_eiu_irq[MAX_EIU] = {
	LTQ_EIU_IR0,
	LTQ_EIU_IR1,
	LTQ_EIU_IR2,
	LTQ_EIU_IR3,
	LTQ_EIU_IR4,
	LTQ_EIU_IR5,
};

static struct resource ltq_icu_resource = {
	.name	= "icu",
	.start	= LTQ_ICU_BASE_ADDR,
	.end	= LTQ_ICU_BASE_ADDR + LTQ_ICU_SIZE - 1,
	.flags	= IORESOURCE_MEM,
};

static struct resource ltq_eiu_resource = {
	.name	= "eiu",
	.start	= LTQ_EIU_BASE_ADDR,
	.end	= LTQ_EIU_BASE_ADDR + LTQ_ICU_SIZE - 1,
	.flags	= IORESOURCE_MEM,
};

static void __iomem *ltq_icu_membase;
static void __iomem *ltq_eiu_membase;

void ltq_disable_irq(struct irq_data *d)
{
	u32 ier = LTQ_ICU_IM0_IER;
	int irq_nr = d->irq - INT_NUM_IRQ0;

	ier += LTQ_ICU_OFFSET * (irq_nr / INT_NUM_IM_OFFSET);
	irq_nr %= INT_NUM_IM_OFFSET;
	ltq_icu_w32(ltq_icu_r32(ier) & ~(1 << irq_nr), ier);
=======
/* we have a cascade of 8 irqs */
#define MIPS_CPU_IRQ_CASCADE		8

static int exin_avail;
static u32 ltq_eiu_irq[MAX_EIU];
static void __iomem *ltq_icu_membase[NR_CPUS];
static void __iomem *ltq_eiu_membase;
static struct irq_domain *ltq_domain;
static DEFINE_SPINLOCK(ltq_eiu_lock);
static DEFINE_RAW_SPINLOCK(ltq_icu_lock);
static int ltq_perfcount_irq;

int ltq_eiu_get_irq(int exin)
{
	if (exin < exin_avail)
		return ltq_eiu_irq[exin];
	return -1;
}

void ltq_disable_irq(struct irq_data *d)
{
	unsigned long offset = d->hwirq - MIPS_CPU_IRQ_CASCADE;
	unsigned long im = offset / INT_NUM_IM_OFFSET;
	unsigned long flags;
	int vpe;

	offset %= INT_NUM_IM_OFFSET;

	raw_spin_lock_irqsave(&ltq_icu_lock, flags);
	for_each_present_cpu(vpe) {
		ltq_icu_w32(vpe, im,
			    ltq_icu_r32(vpe, im, LTQ_ICU_IER) & ~BIT(offset),
			    LTQ_ICU_IER);
	}
	raw_spin_unlock_irqrestore(&ltq_icu_lock, flags);
>>>>>>> 26f1d324c6e (tools: use basename to identify file in gen-mach-types)
}

void ltq_mask_and_ack_irq(struct irq_data *d)
{
<<<<<<< HEAD
	u32 ier = LTQ_ICU_IM0_IER;
	u32 isr = LTQ_ICU_IM0_ISR;
	int irq_nr = d->irq - INT_NUM_IRQ0;

	ier += LTQ_ICU_OFFSET * (irq_nr / INT_NUM_IM_OFFSET);
	isr += LTQ_ICU_OFFSET * (irq_nr / INT_NUM_IM_OFFSET);
	irq_nr %= INT_NUM_IM_OFFSET;
	ltq_icu_w32(ltq_icu_r32(ier) & ~(1 << irq_nr), ier);
	ltq_icu_w32((1 << irq_nr), isr);
=======
	unsigned long offset = d->hwirq - MIPS_CPU_IRQ_CASCADE;
	unsigned long im = offset / INT_NUM_IM_OFFSET;
	unsigned long flags;
	int vpe;

	offset %= INT_NUM_IM_OFFSET;

	raw_spin_lock_irqsave(&ltq_icu_lock, flags);
	for_each_present_cpu(vpe) {
		ltq_icu_w32(vpe, im,
			    ltq_icu_r32(vpe, im, LTQ_ICU_IER) & ~BIT(offset),
			    LTQ_ICU_IER);
		ltq_icu_w32(vpe, im, BIT(offset), LTQ_ICU_ISR);
	}
	raw_spin_unlock_irqrestore(&ltq_icu_lock, flags);
>>>>>>> 26f1d324c6e (tools: use basename to identify file in gen-mach-types)
}

static void ltq_ack_irq(struct irq_data *d)
{
<<<<<<< HEAD
	u32 isr = LTQ_ICU_IM0_ISR;
	int irq_nr = d->irq - INT_NUM_IRQ0;

	isr += LTQ_ICU_OFFSET * (irq_nr / INT_NUM_IM_OFFSET);
	irq_nr %= INT_NUM_IM_OFFSET;
	ltq_icu_w32((1 << irq_nr), isr);
=======
	unsigned long offset = d->hwirq - MIPS_CPU_IRQ_CASCADE;
	unsigned long im = offset / INT_NUM_IM_OFFSET;
	unsigned long flags;
	int vpe;

	offset %= INT_NUM_IM_OFFSET;

	raw_spin_lock_irqsave(&ltq_icu_lock, flags);
	for_each_present_cpu(vpe) {
		ltq_icu_w32(vpe, im, BIT(offset), LTQ_ICU_ISR);
	}
	raw_spin_unlock_irqrestore(&ltq_icu_lock, flags);
>>>>>>> 26f1d324c6e (tools: use basename to identify file in gen-mach-types)
}

void ltq_enable_irq(struct irq_data *d)
{
<<<<<<< HEAD
	u32 ier = LTQ_ICU_IM0_IER;
	int irq_nr = d->irq - INT_NUM_IRQ0;

	ier += LTQ_ICU_OFFSET  * (irq_nr / INT_NUM_IM_OFFSET);
	irq_nr %= INT_NUM_IM_OFFSET;
	ltq_icu_w32(ltq_icu_r32(ier) | (1 << irq_nr), ier);
=======
	unsigned long offset = d->hwirq - MIPS_CPU_IRQ_CASCADE;
	unsigned long im = offset / INT_NUM_IM_OFFSET;
	unsigned long flags;
	int vpe;

	offset %= INT_NUM_IM_OFFSET;

	vpe = cpumask_first(irq_data_get_effective_affinity_mask(d));

	/* This shouldn't be even possible, maybe during CPU hotplug spam */
	if (unlikely(vpe >= nr_cpu_ids))
		vpe = smp_processor_id();

	raw_spin_lock_irqsave(&ltq_icu_lock, flags);

	ltq_icu_w32(vpe, im, ltq_icu_r32(vpe, im, LTQ_ICU_IER) | BIT(offset),
		    LTQ_ICU_IER);

	raw_spin_unlock_irqrestore(&ltq_icu_lock, flags);
}

static int ltq_eiu_settype(struct irq_data *d, unsigned int type)
{
	int i;
	unsigned long flags;

	for (i = 0; i < exin_avail; i++) {
		if (d->hwirq == ltq_eiu_irq[i]) {
			int val = 0;
			int edge = 0;

			switch (type) {
			case IRQF_TRIGGER_NONE:
				break;
			case IRQF_TRIGGER_RISING:
				val = 1;
				edge = 1;
				break;
			case IRQF_TRIGGER_FALLING:
				val = 2;
				edge = 1;
				break;
			case IRQF_TRIGGER_RISING | IRQF_TRIGGER_FALLING:
				val = 3;
				edge = 1;
				break;
			case IRQF_TRIGGER_HIGH:
				val = 5;
				break;
			case IRQF_TRIGGER_LOW:
				val = 6;
				break;
			default:
				pr_err("invalid type %d for irq %ld\n",
					type, d->hwirq);
				return -EINVAL;
			}

			if (edge)
				irq_set_handler(d->hwirq, handle_edge_irq);

			spin_lock_irqsave(&ltq_eiu_lock, flags);
			ltq_eiu_w32((ltq_eiu_r32(LTQ_EIU_EXIN_C) &
				    (~(7 << (i * 4)))) | (val << (i * 4)),
				    LTQ_EIU_EXIN_C);
			spin_unlock_irqrestore(&ltq_eiu_lock, flags);
		}
	}

	return 0;
>>>>>>> 26f1d324c6e (tools: use basename to identify file in gen-mach-types)
}

static unsigned int ltq_startup_eiu_irq(struct irq_data *d)
{
	int i;

	ltq_enable_irq(d);
<<<<<<< HEAD
	for (i = 0; i < MAX_EIU; i++) {
		if (d->irq == ltq_eiu_irq[i]) {
			/* low level - we should really handle set_type */
			ltq_eiu_w32(ltq_eiu_r32(LTQ_EIU_EXIN_C) |
				(0x6 << (i * 4)), LTQ_EIU_EXIN_C);
			/* clear all pending */
			ltq_eiu_w32(ltq_eiu_r32(LTQ_EIU_EXIN_INIC) & ~(1 << i),
				LTQ_EIU_EXIN_INIC);
			/* enable */
			ltq_eiu_w32(ltq_eiu_r32(LTQ_EIU_EXIN_INEN) | (1 << i),
=======
	for (i = 0; i < exin_avail; i++) {
		if (d->hwirq == ltq_eiu_irq[i]) {
			/* by default we are low level triggered */
			ltq_eiu_settype(d, IRQF_TRIGGER_LOW);
			/* clear all pending */
			ltq_eiu_w32(ltq_eiu_r32(LTQ_EIU_EXIN_INC) & ~BIT(i),
				LTQ_EIU_EXIN_INC);
			/* enable */
			ltq_eiu_w32(ltq_eiu_r32(LTQ_EIU_EXIN_INEN) | BIT(i),
>>>>>>> 26f1d324c6e (tools: use basename to identify file in gen-mach-types)
				LTQ_EIU_EXIN_INEN);
			break;
		}
	}

	return 0;
}

static void ltq_shutdown_eiu_irq(struct irq_data *d)
{
	int i;

	ltq_disable_irq(d);
<<<<<<< HEAD
	for (i = 0; i < MAX_EIU; i++) {
		if (d->irq == ltq_eiu_irq[i]) {
			/* disable */
			ltq_eiu_w32(ltq_eiu_r32(LTQ_EIU_EXIN_INEN) & ~(1 << i),
=======
	for (i = 0; i < exin_avail; i++) {
		if (d->hwirq == ltq_eiu_irq[i]) {
			/* disable */
			ltq_eiu_w32(ltq_eiu_r32(LTQ_EIU_EXIN_INEN) & ~BIT(i),
>>>>>>> 26f1d324c6e (tools: use basename to identify file in gen-mach-types)
				LTQ_EIU_EXIN_INEN);
			break;
		}
	}
}

<<<<<<< HEAD
static struct irq_chip ltq_irq_type = {
	"icu",
=======
#if defined(CONFIG_SMP)
static int ltq_icu_irq_set_affinity(struct irq_data *d,
				    const struct cpumask *cpumask, bool force)
{
	struct cpumask tmask;

	if (!cpumask_and(&tmask, cpumask, cpu_online_mask))
		return -EINVAL;

	irq_data_update_effective_affinity(d, &tmask);

	return IRQ_SET_MASK_OK;
}
#endif

static struct irq_chip ltq_irq_type = {
	.name = "icu",
>>>>>>> 26f1d324c6e (tools: use basename to identify file in gen-mach-types)
	.irq_enable = ltq_enable_irq,
	.irq_disable = ltq_disable_irq,
	.irq_unmask = ltq_enable_irq,
	.irq_ack = ltq_ack_irq,
	.irq_mask = ltq_disable_irq,
	.irq_mask_ack = ltq_mask_and_ack_irq,
<<<<<<< HEAD
};

static struct irq_chip ltq_eiu_type = {
	"eiu",
=======
#if defined(CONFIG_SMP)
	.irq_set_affinity = ltq_icu_irq_set_affinity,
#endif
};

static struct irq_chip ltq_eiu_type = {
	.name = "eiu",
>>>>>>> 26f1d324c6e (tools: use basename to identify file in gen-mach-types)
	.irq_startup = ltq_startup_eiu_irq,
	.irq_shutdown = ltq_shutdown_eiu_irq,
	.irq_enable = ltq_enable_irq,
	.irq_disable = ltq_disable_irq,
	.irq_unmask = ltq_enable_irq,
	.irq_ack = ltq_ack_irq,
	.irq_mask = ltq_disable_irq,
	.irq_mask_ack = ltq_mask_and_ack_irq,
<<<<<<< HEAD
};

static void ltq_hw_irqdispatch(int module)
{
	u32 irq;

	irq = ltq_icu_r32(LTQ_ICU_IM0_IOSR + (module * LTQ_ICU_OFFSET));
	if (irq == 0)
		return;

	/* silicon bug causes only the msb set to 1 to be valid. all
	 * other bits might be bogus
	 */
	irq = __fls(irq);
	do_IRQ((int)irq + INT_NUM_IM0_IRL0 + (INT_NUM_IM_OFFSET * module));

	/* if this is a EBU irq, we need to ack it or get a deadlock */
	if ((irq == LTQ_ICU_EBU_IRQ) && (module == 0))
=======
	.irq_set_type = ltq_eiu_settype,
#if defined(CONFIG_SMP)
	.irq_set_affinity = ltq_icu_irq_set_affinity,
#endif
};

static void ltq_hw_irq_handler(struct irq_desc *desc)
{
	unsigned int module = irq_desc_get_irq(desc) - 2;
	u32 irq;
	irq_hw_number_t hwirq;
	int vpe = smp_processor_id();

	irq = ltq_icu_r32(vpe, module, LTQ_ICU_IOSR);
	if (irq == 0)
		return;

	/*
	 * silicon bug causes only the msb set to 1 to be valid. all
	 * other bits might be bogus
	 */
	irq = __fls(irq);
	hwirq = irq + MIPS_CPU_IRQ_CASCADE + (INT_NUM_IM_OFFSET * module);
	generic_handle_domain_irq(ltq_domain, hwirq);

	/* if this is a EBU irq, we need to ack it or get a deadlock */
	if (irq == LTQ_ICU_EBU_IRQ && !module && LTQ_EBU_PCC_ISTAT != 0)
>>>>>>> 26f1d324c6e (tools: use basename to identify file in gen-mach-types)
		ltq_ebu_w32(ltq_ebu_r32(LTQ_EBU_PCC_ISTAT) | 0x10,
			LTQ_EBU_PCC_ISTAT);
}

<<<<<<< HEAD
#define DEFINE_HWx_IRQDISPATCH(x)					\
	static void ltq_hw ## x ## _irqdispatch(void)			\
	{								\
		ltq_hw_irqdispatch(x);					\
	}
DEFINE_HWx_IRQDISPATCH(0)
DEFINE_HWx_IRQDISPATCH(1)
DEFINE_HWx_IRQDISPATCH(2)
DEFINE_HWx_IRQDISPATCH(3)
DEFINE_HWx_IRQDISPATCH(4)

static void ltq_hw5_irqdispatch(void)
{
	do_IRQ(MIPS_CPU_TIMER_IRQ);
}

asmlinkage void plat_irq_dispatch(void)
{
	unsigned int pending = read_c0_status() & read_c0_cause() & ST0_IM;
	unsigned int i;

	if (pending & CAUSEF_IP7) {
		do_IRQ(MIPS_CPU_TIMER_IRQ);
		goto out;
	} else {
		for (i = 0; i < 5; i++) {
			if (pending & (CAUSEF_IP2 << i)) {
				ltq_hw_irqdispatch(i);
				goto out;
			}
		}
	}
	pr_alert("Spurious IRQ: CAUSE=0x%08x\n", read_c0_status());

out:
	return;
}

static struct irqaction cascade = {
	.handler = no_action,
	.name = "cascade",
};

void __init arch_init_irq(void)
{
	int i;

	if (insert_resource(&iomem_resource, &ltq_icu_resource) < 0)
		panic("Failed to insert icu memory");

	if (request_mem_region(ltq_icu_resource.start,
			resource_size(&ltq_icu_resource), "icu") < 0)
		panic("Failed to request icu memory");

	ltq_icu_membase = ioremap_nocache(ltq_icu_resource.start,
				resource_size(&ltq_icu_resource));
	if (!ltq_icu_membase)
		panic("Failed to remap icu memory");

	if (insert_resource(&iomem_resource, &ltq_eiu_resource) < 0)
		panic("Failed to insert eiu memory");

	if (request_mem_region(ltq_eiu_resource.start,
			resource_size(&ltq_eiu_resource), "eiu") < 0)
		panic("Failed to request eiu memory");

	ltq_eiu_membase = ioremap_nocache(ltq_eiu_resource.start,
				resource_size(&ltq_eiu_resource));
	if (!ltq_eiu_membase)
		panic("Failed to remap eiu memory");

	/* make sure all irqs are turned off by default */
	for (i = 0; i < 5; i++)
		ltq_icu_w32(0, LTQ_ICU_IM0_IER + (i * LTQ_ICU_OFFSET));

	/* clear all possibly pending interrupts */
	ltq_icu_w32(~0, LTQ_ICU_IM0_ISR + (i * LTQ_ICU_OFFSET));

	mips_cpu_irq_init();

	for (i = 2; i <= 6; i++)
		setup_irq(i, &cascade);

	if (cpu_has_vint) {
		pr_info("Setting up vectored interrupts\n");
		set_vi_handler(2, ltq_hw0_irqdispatch);
		set_vi_handler(3, ltq_hw1_irqdispatch);
		set_vi_handler(4, ltq_hw2_irqdispatch);
		set_vi_handler(5, ltq_hw3_irqdispatch);
		set_vi_handler(6, ltq_hw4_irqdispatch);
		set_vi_handler(7, ltq_hw5_irqdispatch);
	}

	for (i = INT_NUM_IRQ0;
		i <= (INT_NUM_IRQ0 + (5 * INT_NUM_IM_OFFSET)); i++)
		if ((i == LTQ_EIU_IR0) || (i == LTQ_EIU_IR1) ||
			(i == LTQ_EIU_IR2))
			irq_set_chip_and_handler(i, &ltq_eiu_type,
				handle_level_irq);
		/* EIU3-5 only exist on ar9 and vr9 */
		else if (((i == LTQ_EIU_IR3) || (i == LTQ_EIU_IR4) ||
			(i == LTQ_EIU_IR5)) && (ltq_is_ar9() || ltq_is_vr9()))
			irq_set_chip_and_handler(i, &ltq_eiu_type,
				handle_level_irq);
		else
			irq_set_chip_and_handler(i, &ltq_irq_type,
				handle_level_irq);

#if !defined(CONFIG_MIPS_MT_SMP) && !defined(CONFIG_MIPS_MT_SMTC)
	set_c0_status(IE_IRQ0 | IE_IRQ1 | IE_IRQ2 |
		IE_IRQ3 | IE_IRQ4 | IE_IRQ5);
#else
	set_c0_status(IE_SW0 | IE_SW1 | IE_IRQ0 | IE_IRQ1 |
		IE_IRQ2 | IE_IRQ3 | IE_IRQ4 | IE_IRQ5);
#endif
}

unsigned int __cpuinit get_c0_compare_int(void)
{
	return CP0_LEGACY_COMPARE_IRQ;
}
=======
static int icu_map(struct irq_domain *d, unsigned int irq, irq_hw_number_t hw)
{
	struct irq_chip *chip = &ltq_irq_type;
	struct irq_data *data;
	int i;

	if (hw < MIPS_CPU_IRQ_CASCADE)
		return 0;

	for (i = 0; i < exin_avail; i++)
		if (hw == ltq_eiu_irq[i])
			chip = &ltq_eiu_type;

	data = irq_get_irq_data(irq);

	irq_data_update_effective_affinity(data, cpumask_of(0));

	irq_set_chip_and_handler(irq, chip, handle_level_irq);

	return 0;
}

static const struct irq_domain_ops irq_domain_ops = {
	.xlate = irq_domain_xlate_onetwocell,
	.map = icu_map,
};

int __init icu_of_init(struct device_node *node, struct device_node *parent)
{
	struct device_node *eiu_node;
	struct resource res;
	int i, ret, vpe;

	/* load register regions of available ICUs */
	for_each_possible_cpu(vpe) {
		if (of_address_to_resource(node, vpe, &res))
			panic("Failed to get icu%i memory range", vpe);

		if (!request_mem_region(res.start, resource_size(&res),
					res.name))
			pr_err("Failed to request icu%i memory\n", vpe);

		ltq_icu_membase[vpe] = ioremap(res.start,
					resource_size(&res));

		if (!ltq_icu_membase[vpe])
			panic("Failed to remap icu%i memory", vpe);
	}

	/* turn off all irqs by default */
	for_each_possible_cpu(vpe) {
		for (i = 0; i < MAX_IM; i++) {
			/* make sure all irqs are turned off by default */
			ltq_icu_w32(vpe, i, 0, LTQ_ICU_IER);

			/* clear all possibly pending interrupts */
			ltq_icu_w32(vpe, i, ~0, LTQ_ICU_ISR);
			ltq_icu_w32(vpe, i, ~0, LTQ_ICU_IMR);

			/* clear resend */
			ltq_icu_w32(vpe, i, 0, LTQ_ICU_IRSR);
		}
	}

	mips_cpu_irq_init();

	for (i = 0; i < MAX_IM; i++)
		irq_set_chained_handler(i + 2, ltq_hw_irq_handler);

	ltq_domain = irq_domain_add_linear(node,
		(MAX_IM * INT_NUM_IM_OFFSET) + MIPS_CPU_IRQ_CASCADE,
		&irq_domain_ops, 0);

	/* tell oprofile which irq to use */
	ltq_perfcount_irq = irq_create_mapping(ltq_domain, LTQ_PERF_IRQ);

	/* the external interrupts are optional and xway only */
	eiu_node = of_find_compatible_node(NULL, NULL, "lantiq,eiu-xway");
	if (eiu_node && !of_address_to_resource(eiu_node, 0, &res)) {
		/* find out how many external irq sources we have */
		exin_avail = of_property_count_u32_elems(eiu_node,
							 "lantiq,eiu-irqs");

		if (exin_avail > MAX_EIU)
			exin_avail = MAX_EIU;

		ret = of_property_read_u32_array(eiu_node, "lantiq,eiu-irqs",
						ltq_eiu_irq, exin_avail);
		if (ret)
			panic("failed to load external irq resources");

		if (!request_mem_region(res.start, resource_size(&res),
							res.name))
			pr_err("Failed to request eiu memory");

		ltq_eiu_membase = ioremap(res.start,
							resource_size(&res));
		if (!ltq_eiu_membase)
			panic("Failed to remap eiu memory");
	}
	of_node_put(eiu_node);

	return 0;
}

int get_c0_perfcount_int(void)
{
	return ltq_perfcount_irq;
}
EXPORT_SYMBOL_GPL(get_c0_perfcount_int);

unsigned int get_c0_compare_int(void)
{
	return CP0_LEGACY_COMPARE_IRQ;
}

IRQCHIP_DECLARE(lantiq_icu, "lantiq,icu", icu_of_init);

void __init arch_init_irq(void)
{
	irqchip_init();
}
>>>>>>> 26f1d324c6e (tools: use basename to identify file in gen-mach-types)
