#!/bin/sh
<<<<<<< HEAD
#
# This scripts adds local version information from the version
# control systems git, mercurial (hg) and subversion (svn).
=======
# SPDX-License-Identifier: GPL-2.0
#
# This scripts adds local version information from the version
# control system git.
>>>>>>> 26f1d324c6e (tools: use basename to identify file in gen-mach-types)
#
# If something goes wrong, send a mail the kernel build mailinglist
# (see MAINTAINERS) and CC Nico Schottelius
# <nico-linuxsetlocalversion -at- schottelius.org>.
#
#

usage() {
<<<<<<< HEAD
	echo "Usage: $0 [--save-scmversion] [srctree]" >&2
	exit 1
}

scm_only=false
srctree=.
if test "$1" = "--save-scmversion"; then
	scm_only=true
	shift
fi
=======
	echo "Usage: $0 [--no-local] [srctree]" >&2
	exit 1
}

no_local=false
if test "$1" = "--no-local"; then
	no_local=true
	shift
fi

srctree=.
>>>>>>> 26f1d324c6e (tools: use basename to identify file in gen-mach-types)
if test $# -gt 0; then
	srctree=$1
	shift
fi
if test $# -gt 0 -o ! -d "$srctree"; then
	usage
fi

scm_version()
{
<<<<<<< HEAD
	local short
	short=false

	cd "$srctree"
	if test -e .scmversion; then
		cat .scmversion
		return
	fi
	if test "$1" = "--short"; then
		short=true
	fi

	# Check for git and a git repo.
	if test -d .git && head=`git rev-parse --verify --short HEAD 2>/dev/null`; then

		# If we are at a tagged commit (like "v2.6.30-rc6"), we ignore
		# it, because this version is defined in the top level Makefile.
		if atag="`git describe --exact-match --abbrev=0 2>/dev/null`"; then
			# Make sure we're at the tag that matches the Makefile.
			# If not place the hash of the tag as well for
			# v2.6.30-rc5-g314aef
			if [ "x$atag" != "x$VERSION" ]; then
				# If only the short version is requested,
				# don't bother running further git commands
				if $short; then
					echo "+"
					return
				fi
				printf '%s%s' -g "`git show-ref -s --abbrev --tags $atag 2>/dev/null`"
			fi
		else

			# If only the short version is requested, don't bother
			# running further git commands
			if $short; then
				echo "+"
				return
			fi
			# If we are past a tagged commit (like
			# "v2.6.30-rc5-302-g72357d5"), we pretty print it and
			# include the hash of any new tag on top.
			if atag="`git describe 2>/dev/null`"; then
				tag="`git describe --abbrev=0 2>/dev/null`"
				commit="`echo "$atag" | awk -F- '{printf("-%05d-%s", $(NF-1),$(NF))}'`"
				printf '%s%s%s' -g "`git show-ref -s --abbrev --tags $tag 2>/dev/null`" $commit
			# If we don't have a tag at all we print -g{commitish}.
			else
				printf '%s%s' -g $head
			fi
		fi

		# Is this git on svn?
		if git config --get svn-remote.svn.url >/dev/null; then
			printf -- '-svn%s' "`git svn find-rev $head`"
		fi

		# Update index only on r/w media
		[ -w . ] && git update-index --refresh --unmerged > /dev/null

		# Check for uncommitted changes
		if git diff-index --name-only HEAD | grep -qv "^scripts/package"; then
			printf '%s' -dirty
		fi

		# All done with git
		return
	fi

	# Check for mercurial and a mercurial repo.
	if test -d .hg && hgid=`hg id 2>/dev/null`; then
		# Do we have an tagged version?  If so, latesttagdistance == 1
		if [ "`hg log -r . --template '{latesttagdistance}'`" == "1" ]; then
			id=`hg log -r . --template '{latesttag}'`
			printf '%s%s' -hg "$id"
		else
			tag=`printf '%s' "$hgid" | cut -d' ' -f2`
			if [ -z "$tag" -o "$tag" = tip ]; then
				id=`printf '%s' "$hgid" | sed 's/[+ ].*//'`
				printf '%s%s' -hg "$id"
			fi
		fi

		# Are there uncommitted changes?
		# These are represented by + after the changeset id.
		case "$hgid" in
			*+|*+\ *) printf '%s' -dirty ;;
		esac

		# All done with mercurial
		return
	fi

	# Check for svn and a svn repo.
	if rev=`svn info 2>/dev/null | grep '^Last Changed Rev'`; then
		rev=`echo $rev | awk '{print $NF}'`
		printf -- '-svn%s' "$rev"

		# All done with svn
		return
	fi
=======
	local short=false
	local no_dirty=false
	local tag

	while [ $# -gt 0 ];
	do
		case "$1" in
		--short)
			short=true;;
		--no-dirty)
			no_dirty=true;;
		esac
		shift
	done

	cd "$srctree"

	if test -n "$(git rev-parse --show-cdup 2>/dev/null)"; then
		return
	fi

	if ! head=$(git rev-parse --verify HEAD 2>/dev/null); then
		return
	fi

	# mainline kernel:  6.2.0-rc5  ->  v6.2-rc5
	# stable kernel:    6.1.7      ->  v6.1.7
	version_tag=v$(echo "${KERNELVERSION}" | sed -E 's/^([0-9]+\.[0-9]+)\.0(.*)$/\1\2/')

	# If a localversion* file exists, and the corresponding
	# annotated tag exists and is an ancestor of HEAD, use
	# it. This is the case in linux-next.
	tag=${file_localversion#-}
	desc=
	if [ -n "${tag}" ]; then
		desc=$(git describe --match=$tag 2>/dev/null)
	fi

	# Otherwise, if a localversion* file exists, and the tag
	# obtained by appending it to the tag derived from
	# KERNELVERSION exists and is an ancestor of HEAD, use
	# it. This is e.g. the case in linux-rt.
	if [ -z "${desc}" ] && [ -n "${file_localversion}" ]; then
		tag="${version_tag}${file_localversion}"
		desc=$(git describe --match=$tag 2>/dev/null)
	fi

	# Otherwise, default to the annotated tag derived from KERNELVERSION.
	if [ -z "${desc}" ]; then
		tag="${version_tag}"
		desc=$(git describe --match=$tag 2>/dev/null)
	fi

	# If we are at the tagged commit, we ignore it because the version is
	# well-defined.
	if [ "${tag}" != "${desc}" ]; then

		# If only the short version is requested, don't bother
		# running further git commands
		if $short; then
			echo "+"
			return
		fi
		# If we are past the tagged commit, we pretty print it.
		# (like 6.1.0-14595-g292a089d78d3)
		if [ -n "${desc}" ]; then
			echo "${desc}" | awk -F- '{printf("-%05d", $(NF-1))}'
		fi

		# Add -g and exactly 12 hex chars.
		printf '%s%s' -g "$(echo $head | cut -c1-12)"
	fi

	if ${no_dirty}; then
		return
	fi

	# Check for uncommitted changes.
	# This script must avoid any write attempt to the source tree, which
	# might be read-only.
	# You cannot use 'git describe --dirty' because it tries to create
	# .git/index.lock .
	# First, with git-status, but --no-optional-locks is only supported in
	# git >= 2.14, so fall back to git-diff-index if it fails. Note that
	# git-diff-index does not refresh the index, so it may give misleading
	# results.
	# See git-update-index(1), git-diff-index(1), and git-status(1).
	if {
		git --no-optional-locks status -uno --porcelain 2>/dev/null ||
		git diff-index --name-only HEAD
	} | read dummy; then
		printf '%s' -dirty
	fi
>>>>>>> 26f1d324c6e (tools: use basename to identify file in gen-mach-types)
}

collect_files()
{
<<<<<<< HEAD
	local file res
=======
	local file res=
>>>>>>> 26f1d324c6e (tools: use basename to identify file in gen-mach-types)

	for file; do
		case "$file" in
		*\~*)
			continue
			;;
		esac
		if test -e "$file"; then
			res="$res$(cat "$file")"
		fi
	done
	echo "$res"
}

<<<<<<< HEAD
if $scm_only; then
	if test ! -e .scmversion; then
		res=$(scm_version)
		echo "$res" >.scmversion
	fi
	exit
fi

if test -e include/config/auto.conf; then
	. include/config/auto.conf
else
	echo "Error: kernelrelease not valid - run 'make prepare' to update it"
=======
if [ -z "${KERNELVERSION}" ]; then
	echo "KERNELVERSION is not set" >&2
>>>>>>> 26f1d324c6e (tools: use basename to identify file in gen-mach-types)
	exit 1
fi

# localversion* files in the build and source directory
<<<<<<< HEAD
res="$(collect_files localversion*)"
if test ! "$srctree" -ef .; then
	res="$res$(collect_files "$srctree"/localversion*)"
fi

# CONFIG_LOCALVERSION and LOCALVERSION (if set)
res="${res}${CONFIG_LOCALVERSION}${LOCALVERSION}"

# scm version string if not at a tagged commit
if test "$CONFIG_LOCALVERSION_AUTO" = "y"; then
	# full scm version string
	res="$res$(scm_version)"
else
	# append a plus sign if the repository is not in a clean
	# annotated or signed tagged state (as git describe only
	# looks at signed or annotated tags - git tag -a/-s) and
	# LOCALVERSION= is not specified
	if test "${LOCALVERSION+set}" != "set"; then
		scm=$(scm_version --short)
		res="$res${scm:++}"
	fi
fi

echo "$res"
=======
file_localversion="$(collect_files localversion*)"
if test ! "$srctree" -ef .; then
	file_localversion="${file_localversion}$(collect_files "$srctree"/localversion*)"
fi

if ${no_local}; then
	echo "${KERNELVERSION}$(scm_version --no-dirty)"
	exit 0
fi

if ! test -e include/config/auto.conf; then
	echo "Error: kernelrelease not valid - run 'make prepare' to update it" >&2
	exit 1
fi

# version string from CONFIG_LOCALVERSION
config_localversion=$(sed -n 's/^CONFIG_LOCALVERSION=\(.*\)$/\1/p' include/config/auto.conf)

# scm version string if not at the kernel version tag or at the file_localversion
if grep -q "^CONFIG_LOCALVERSION_AUTO=y$" include/config/auto.conf; then
	# full scm version string
	scm_version="$(scm_version)"
elif [ "${LOCALVERSION+set}" != "set" ]; then
	# If the variable LOCALVERSION is not set, append a plus
	# sign if the repository is not in a clean annotated or
	# signed tagged state (as git describe only looks at signed
	# or annotated tags - git tag -a/-s).
	#
	# If the variable LOCALVERSION is set (including being set
	# to an empty string), we don't want to append a plus sign.
	scm_version="$(scm_version --short)"
fi

echo "${KERNELVERSION}${file_localversion}${config_localversion}${LOCALVERSION}${scm_version}"
>>>>>>> 26f1d324c6e (tools: use basename to identify file in gen-mach-types)
